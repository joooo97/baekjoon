import java.util.*;
import java.io.*;

// 최소 비용 = 가중치 = 시간
// 가중치인 시간이 모두 1이므로 BFS를 이용하여 문제 풀이
public class Main {
	public static int[] time = new int[100001];
	public static int[] prev = new int[100001]; // 경로: 이전 정점을 저장
	public static StringBuilder sb = new StringBuilder();
	
	public static void printPath(int n, int k) {
		if(n != k) printPath(n, prev[k]);
		
		sb.append(k).append(" ");
	}
	
	public static void bfs(int n, int k) {
		Queue<Integer> q = new LinkedList<>();
		q.offer(n);
//		time[n] = 0;
		
		while(!q.isEmpty()) {
			int x = q.poll();
			
			// 동생을 만났다면
			if(x == k) {
				sb.append(time[k]).append("\n");
				printPath(n, k);
				System.out.print(sb);
				System.exit(0);
			}
			
			// x - 1로 이동
			if(x - 1 >= 0 && time[x - 1] == 0) {
				q.offer(x - 1);
				time[x - 1] = time[x] + 1;
				prev[x - 1] = x; // 이전 경로 기록
			}
			
			// x + 1로 이동
			if(x + 1 <= 100000 && time[x + 1] == 0) {
				q.offer(x + 1);
				time[x + 1] = time[x] + 1;
				prev[x + 1] = x;
			}
			
			// 2 * x로 이동
			if(2 * x <= 100000 && time[2 * x] == 0) {
				q.offer(2 * x);
				time[2 * x] = time[x] + 1;
				prev[2 * x] = x;
			}
			
		}
	}
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int k = Integer.parseInt(st.nextToken());
		bfs(n, k);
	}
	
}